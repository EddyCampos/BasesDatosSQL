-- INSTITUTO NACIONAL DE APRENDIZAJE
-- PROGRAMADOR DE APLICACIONES
-- MÓDULO: GESTIÓN DE BASES DE DATOS
-- PROFESOR: LUIS CHACÓN ZUÑIGA
-- ESTUDIANTE: EDDY CAMPOS JIMÉNEZ
-- PROYECTO BASE DE DATOS MATRICULA
-- FECHA CREACIÓN: 16 FEB 2023
-- ULTIMA ACTUALIZACION: 19 FEBRERO 2023
----------------------------------------------------------------------------------------
USE EDDY_PROYECTOBD_FASE2
GO
----------------------------------------------------------------------------------------
--CRUD *********************************************************************************
--TABLA ESTUDIANTES ********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_ESTUDIANTE(@ID_ESTUDIANTE varchar(10),
									 @CARNET varchar(10),
									 @NOMBRE varchar(20),
									 @APELLIDO1 varchar(20),
									 @APELLIDO2 varchar(20),
									 @NUMCEDULA varchar(20),
									 @F_NACIMIENTO date,
									 @PAIS varchar(20),
									 @PROVINCIA varchar(20),
									 @CANTON varchar(20),
									 @DISTRITO varchar(20),
									 @DIRECCION_EXACTA varchar(200),
									 @ESTADO_CIVIL varchar(20),
									 @NUM_TELEFONO varchar(10),
									 @EMAIL varchar(40),
									 @F_INGRESO date,
									 @ESTADO varchar(3),
									 @BORRADO_E bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION 
			IF (NOT EXISTS(SELECT 1 FROM ESTUDIANTES WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE))	
				BEGIN
					INSERT INTO ESTUDIANTES(ID_ESTUDIANTE, CARNET, NOMBRE, APELLIDO_01, APELLIDO_02, NUM_CEDULA, F_NACIMIENTO, PAIS, PROVINCIA, CANTON, DISTRITO, DIRECCION_EXACTA, ESTADO_CIVIL, NUM_TELEFONO, EMAIL, F_INGRESO, ESTADO, BORRADO_E)
						VALUES(@ID_ESTUDIANTE, @CARNET, @NOMBRE, @APELLIDO1, @APELLIDO2, @NUMCEDULA, @F_NACIMIENTO, @PAIS, @PROVINCIA, @CANTON, @DISTRITO, @DIRECCION_EXACTA, @ESTADO_CIVIL, @NUM_TELEFONO, @EMAIL, @F_INGRESO, @ESTADO, @BORRADO_E)
			
					SET @MSJ = 'ESTUDIANTE AGREGADO SATISFACTORIAMENTE'
				END
			ELSE
				SET @MSJ = 'EL ESTUDIANTE YA EXISTE'
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR....................................................................------------
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_ESTUDIANTE(@ID_ESTUDIANTE varchar(10),
									 @CARNET varchar(10),
									 @NOMBRE varchar(20),
									 @APELLIDO1 varchar(20),
									 @APELLIDO2 varchar(20),
									 @NUMCEDULA varchar(20),
									 @F_NACIMIENTO date,
									 @PAIS varchar(20),
									 @PROVINCIA varchar(20),
									 @CANTON varchar(20),
									 @DISTRITO varchar(20),
									 @DIRECCION_EXACTA varchar(200),
									 @ESTADO_CIVIL varchar(20),
									 @NUM_TELEFONO varchar(10),
									 @EMAIL varchar(40),
									 @F_INGRESO date,
									 @ESTADO varchar(3),
									 @BORRADO_E bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			IF (EXISTS(SELECT 1 FROM ESTUDIANTES WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE))	
				BEGIN
					DELETE FROM ESTUDIANTES WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE			
					SET @MSJ = 'ESTUDIANTE BORRADO SATISFACTORIAMENTE'
				END
			ELSE
				SET @MSJ = 'EL ESTUDIANTE NO SE PUEDE BORRAR PORQUE NO EXISTE'
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_ESTUDIANTE(@ID_ESTUDIANTE varchar(10),
									 @CARNET varchar(10),
									 @NOMBRE varchar(20),
									 @APELLIDO1 varchar(20),
									 @APELLIDO2 varchar(20),
									 @NUMCEDULA varchar(20),
									 @F_NACIMIENTO date,
									 @PAIS varchar(20),
									 @PROVINCIA varchar(20),
									 @CANTON varchar(20),
									 @DISTRITO varchar(20),
									 @DIRECCION_EXACTA varchar(200),
									 @ESTADO_CIVIL varchar(20),
									 @NUM_TELEFONO varchar(10),
									 @EMAIL varchar(40),
									 @F_INGRESO date,
									 @ESTADO varchar(3),
									 @BORRADO_E bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			IF (EXISTS(SELECT 1 FROM ESTUDIANTES WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE))	
				BEGIN
					UPDATE ESTUDIANTES SET
						ID_ESTUDIANTE = @ID_ESTUDIANTE,
						CARNET = @CARNET,
						NOMBRE = @NOMBRE,
						APELLIDO_01 = @APELLIDO1,
						APELLIDO_02 = @APELLIDO2,
						NUM_CEDULA = @NUMCEDULA,
						F_NACIMIENTO = @F_NACIMIENTO,
						PAIS = @PAIS,
						PROVINCIA = @PROVINCIA,
						CANTON = @CANTON,
						DISTRITO = @DISTRITO,
						DIRECCION_EXACTA = @DIRECCION_EXACTA,
						ESTADO_CIVIL = @ESTADO,
						NUM_TELEFONO = @NUM_TELEFONO,
						EMAIL = @EMAIL,
						F_INGRESO = @F_INGRESO,
						ESTADO = @ESTADO,
						BORRADO_E = @BORRADO_E
					WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE
					SET @MSJ = 'ESTUDIANTE ACTUALIZADO SATISFACTORIAMENTE'
				END
			ELSE
				SET @MSJ = 'EL ESTUDIANTE NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA EMPLEADOS **********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_EMPLEADO(@ID_EMPLEADO varchar(10),
									 @CARNET varchar(10),
									 @NOMBRE varchar(20),
									 @APELLIDO1 varchar(20),
									 @APELLIDO2 varchar(20),
									 @NUMCEDULA varchar(20),
									 @F_NACIMIENTO date,
									 @PAIS varchar(20),
									 @PROVINCIA varchar(20),
									 @CANTON varchar(20),
									 @DISTRITO varchar(20),
									 @DIRECCION_EXACTA varchar(200),
									 @ESTADO_CIVIL varchar(20),
									 @NUM_TELEFONO varchar(10),
									 @EMAIL varchar(40),
									 @ESTADO varchar(3),
									 @BORRADO_EM bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM EMPLEADOS WHERE ID_EMPLEADO = @ID_EMPLEADO))
					BEGIN
						INSERT INTO EMPLEADOS(ID_EMPLEADO, CARNET, NOMBRE, APELLIDO_01, APELLIDO_02, NUM_CEDULA, F_NACIMIENTO, PAIS, PROVINCIA, CANTON, DISTRITO, DIRECCION_EXACTA, ESTADO_CIVIL, NUM_TELEFONO, EMAIL, ESTADO, BORRADO_EM)
							VALUES(@ID_EMPLEADO, @CARNET, @NOMBRE, @APELLIDO1, @APELLIDO2, @NUMCEDULA, @F_NACIMIENTO, @PAIS, @PROVINCIA, @CANTON, @DISTRITO, @DIRECCION_EXACTA, @ESTADO_CIVIL, @NUM_TELEFONO, @EMAIL, @ESTADO, @BORRADO_EM)
						SET @MSJ = 'EMPLEADO AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL EMPLEADO YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_EMPLEADO(@ID_EMPLEADO varchar(10),
									 @CARNET varchar(10),
									 @NOMBRE varchar(20),
									 @APELLIDO1 varchar(20),
									 @APELLIDO2 varchar(20),
									 @NUMCEDULA varchar(20),
									 @F_NACIMIENTO date,
									 @PAIS varchar(20),
									 @PROVINCIA varchar(20),
									 @CANTON varchar(20),
									 @DISTRITO varchar(20),
									 @DIRECCION_EXACTA varchar(200),
									 @ESTADO_CIVIL varchar(20),
									 @NUM_TELEFONO varchar(10),
									 @EMAIL varchar(40),
									 @ESTADO varchar(3),
									 @BORRADO_EM bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM EMPLEADOS WHERE ID_EMPLEADO = @ID_EMPLEADO))	
					BEGIN
						DELETE FROM EMPLEADOS WHERE ID_EMPLEADO = @ID_EMPLEADO
						SET @MSJ = 'EMPLEADO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL EMPLEADO NO SE PUEDE BORRAR PORQUE NO EXISTE'

			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_EMPLEADO(@ID_EMPLEADO varchar(10),
									 @CARNET varchar(10),
									 @NOMBRE varchar(20),
									 @APELLIDO1 varchar(20),
									 @APELLIDO2 varchar(20),
									 @NUMCEDULA varchar(20),
									 @F_NACIMIENTO date,
									 @PAIS varchar(20),
									 @PROVINCIA varchar(20),
									 @CANTON varchar(20),
									 @DISTRITO varchar(20),
									 @DIRECCION_EXACTA varchar(200),
									 @ESTADO_CIVIL varchar(20),
									 @NUM_TELEFONO varchar(10),
									 @EMAIL varchar(40),
									 @ESTADO varchar(3),
									 @BORRADO_EM bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM EMPLEADOS WHERE ID_EMPLEADO = @ID_EMPLEADO))	
					BEGIN
						UPDATE EMPLEADOS SET
							ID_EMPLEADO = @ID_EMPLEADO,
							CARNET = @CARNET,
							NOMBRE = @NOMBRE,
							APELLIDO_01 = @APELLIDO1,
							APELLIDO_02 = @APELLIDO2,
							NUM_CEDULA = @NUMCEDULA,
							F_NACIMIENTO = @F_NACIMIENTO,
							PAIS = @PAIS,
							PROVINCIA = @PROVINCIA,
							CANTON = @CANTON,
							DISTRITO = @DISTRITO,
							DIRECCION_EXACTA = @DIRECCION_EXACTA,
							ESTADO_CIVIL = @ESTADO,
							NUM_TELEFONO = @NUM_TELEFONO,
							EMAIL = @EMAIL,
							ESTADO = @ESTADO,
							BORRADO_EM = @BORRADO_EM
						WHERE ID_EMPLEADO = @ID_EMPLEADO
						SET @MSJ = 'EMPLEADO ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL EMPLEADO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'

			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
-- TABLA PROFESORES ********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_PROFESORES(@ID_PROFESOR varchar(15),
									 @ID_EMPLEADO varchar(10),
									 @GRADO varchar(30),
									 @NOMBRE_INSTITUCION varchar(30),
									 @DETALLES varchar(200),
									 @BORRADO_P bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM PROFESORES WHERE ID_PROFESOR = @ID_PROFESOR))	
					BEGIN
						INSERT INTO PROFESORES(ID_PROFESOR, ID_EMPLEADO, GRADO, NOMBRE_INSTITUCION, DETALLES, BORRADO_P)
							VALUES(@ID_PROFESOR, @ID_EMPLEADO, @GRADO, @NOMBRE_INSTITUCION, @DETALLES, @BORRADO_P)
						SET @MSJ = 'PROFESOR AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL PROFESOR YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_PROFESORES(@ID_PROFESOR varchar(15),
									 @ID_EMPLEADO varchar(10),
									 @GRADO varchar(30),
									 @NOMBRE_INSTITUCION varchar(30),
									 @DETALLES varchar(200),
									 @BORRADO_P bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM PROFESORES WHERE ID_PROFESOR = @ID_PROFESOR))	
					BEGIN
						DELETE FROM PROFESORES WHERE ID_PROFESOR = @ID_PROFESOR
						SET @MSJ = 'PROFESOR BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL PROFESOR NO SE PUEDE BORRAR PORQUE NO EXISTE'

			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_PROFESORES(@ID_PROFESOR varchar(15),
									 @ID_EMPLEADO varchar(10),
									 @GRADO varchar(30),
									 @NOMBRE_INSTITUCION varchar(30),
									 @DETALLES varchar(200),
									 @BORRADO_P bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM PROFESORES WHERE ID_PROFESOR = @ID_PROFESOR))	
					BEGIN
						UPDATE PROFESORES SET
							ID_PROFESOR = @ID_PROFESOR,
							ID_EMPLEADO = @ID_EMPLEADO,
							GRADO = @GRADO,
							NOMBRE_INSTITUCION = @NOMBRE_INSTITUCION,
							DETALLES = @DETALLES,
							BORRADO_P = @BORRADO_P
						WHERE ID_PROFESOR = @ID_PROFESOR
						SET @MSJ = 'PROFESOR ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL PROFESOR NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'

			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH--SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA CERTIFICACIONES ****************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_CERTIFICACIONES(@ID_CERTIFICADO varchar(15),
									 @NOMBRE_CERTIFICADO varchar(30),
									 @NUM_FOLIO varchar(10),
									 @FECHA_EXPEDICION date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM CERTIFICACIONES WHERE ID_CERTIFICADO = @ID_CERTIFICADO))	
					BEGIN
						INSERT INTO CERTIFICACIONES(ID_CERTIFICADO, NOMBRE_CERTIFICADO, NUM_FOLIO, FECHA_EXPEDICION)
							VALUES(@ID_CERTIFICADO, @NOMBRE_CERTIFICADO, @NUM_FOLIO, @FECHA_EXPEDICION)
						SET @MSJ = 'CERTIFICADO AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL CERTIFICADO YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORAR.................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_CERTIFICACIONES(@ID_CERTIFICADO varchar(15),
									 @NOMBRE_CERTIFICADO varchar(30),
									 @NUM_FOLIO varchar(10),
									 @FECHA_EXPEDICION date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM CERTIFICACIONES WHERE ID_CERTIFICADO = @ID_CERTIFICADO))	
					BEGIN
						DELETE FROM CERTIFICACIONES WHERE ID_CERTIFICADO = @ID_CERTIFICADO
						SET @MSJ = 'CERTIFICADO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL CERTIFICADO NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_CERTIFICACIONES(@ID_CERTIFICADO varchar(15),
									 @NOMBRE_CERTIFICADO varchar(30),
									 @NUM_FOLIO varchar(10),
									 @FECHA_EXPEDICION date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM CERTIFICACIONES WHERE ID_CERTIFICADO = @ID_CERTIFICADO))	
					BEGIN
						UPDATE CERTIFICACIONES SET
							ID_CERTIFICADO = @ID_CERTIFICADO,
							NOMBRE_CERTIFICADO = @NOMBRE_CERTIFICADO,
							NUM_FOLIO = @NUM_FOLIO, 
							FECHA_EXPEDICION = @FECHA_EXPEDICION
						WHERE ID_CERTIFICADO = @ID_CERTIFICADO
						SET @MSJ = 'CERTIFICADO ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL CERTIFICADO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO
--**************************************************************************************
--TABLA PROFESORES_CERTIFICADOS ********************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_PROFESORES_CERTIFICADOS(@ID_PROFESOR_CERTIFICADO varchar(10),
									 @ID_PROFESOR varchar(15),
									 @ID_CERTIFICADO varchar(15),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM PROFESORES_CERTIFICADOS WHERE ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO))	
					BEGIN
						INSERT INTO PROFESORES_CERTIFICADOS(ID_PROFESOR_CERTIFICADO, ID_PROFESOR, ID_CERTIFICADO)
							VALUES(@ID_PROFESOR_CERTIFICADO, @ID_PROFESOR, @ID_CERTIFICADO)
						SET @MSJ = 'PROFESOR CERTIFICADO AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL PROFESOR CERTIFICADO YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_PROFESORES_CERTIFICADOS(@ID_PROFESOR_CERTIFICADO varchar(10),
									 @ID_PROFESOR varchar(15),
									 @ID_CERTIFICADO varchar(15),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM PROFESORES_CERTIFICADOS WHERE ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO))	
					BEGIN
						DELETE FROM PROFESORES_CERTIFICADOS WHERE ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO
						SET @MSJ = 'PROFESOR CERTIFICADO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL PROFESOR CERTIFICADO NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_PROFESORES_CERTIFICADOS(@ID_PROFESOR_CERTIFICADO varchar(10),
									 @ID_PROFESOR varchar(15),
									 @ID_CERTIFICADO varchar(15),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM PROFESORES_CERTIFICADOS WHERE ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO))	
					BEGIN
						UPDATE PROFESORES_CERTIFICADOS SET
							ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO,
							ID_PROFESOR = @ID_PROFESOR,
							ID_CERTIFICADO = @ID_CERTIFICADO
						WHERE ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO
						SET @MSJ = 'PROFESOR CERTIFICADO ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL PROFESOR CERTIFICADO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA MATRICULAS *********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_MATRICULAS(@ID_COMPROBANTE varchar(10),
									 @ID_ESTUDIANTE varchar(10),
									 @ID_MATERIA_ABIERTA varchar(10),
									 @NOTAPONDERADA decimal(10,2),
									 @DESCUENTO decimal(10,2),
									 @DETALLES varchar(200),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM MATRICULAS WHERE ID_COMPROBANTE = @ID_COMPROBANTE))	
					BEGIN
						INSERT INTO MATRICULAS(ID_COMPROBANTE, ID_ESTUDIANTE, ID_MATERIA_ABIERTA, NOTAPONDERADA, DESCUENTO, DETALLES)
							VALUES(@ID_COMPROBANTE, @ID_ESTUDIANTE, @ID_MATERIA_ABIERTA, @NOTAPONDERADA, @DESCUENTO, @DETALLES)
						SET @MSJ = 'MATRICULA AGREGADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATRICULA YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_MATRICULAS(@ID_COMPROBANTE varchar(10),
									 @ID_ESTUDIANTE varchar(10),
									 @ID_MATERIA_ABIERTA varchar(10),
									 @NOTAPONDERADA decimal(10,2),
									 @DESCUENTO decimal(10,2),
									 @DETALLES varchar(200),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM MATRICULAS WHERE ID_COMPROBANTE = @ID_COMPROBANTE))	
					BEGIN
						DELETE FROM MATRICULAS WHERE ID_COMPROBANTE = @ID_COMPROBANTE
						SET @MSJ = 'MATRICULA BORRADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATRICULA NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_MATRICULAS(@ID_COMPROBANTE varchar(10),
									 @ID_ESTUDIANTE varchar(10),
									 @ID_MATERIA_ABIERTA varchar(10),
									 @NOTAPONDERADA decimal(10,2),
									 @DESCUENTO decimal(10,2),
									 @DETALLES varchar(200),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM MATRICULAS WHERE ID_COMPROBANTE = @ID_COMPROBANTE))	
					BEGIN
						UPDATE MATRICULAS SET
							ID_COMPROBANTE = @ID_COMPROBANTE,
							ID_ESTUDIANTE = @ID_ESTUDIANTE,
							ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA,
							NOTAPONDERADA = @NOTAPONDERADA,
							DESCUENTO = @DESCUENTO,
							DETALLES = @DETALLES
						WHERE ID_COMPROBANTE = @ID_COMPROBANTE
						SET @MSJ = 'MATRICULA ACTUALIZADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATRICULA NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA REGISTROS NOTAS ****************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_REGISTRO_NOTAS(@ID_REGISTRO varchar(10),
									 @ID_COMPROBANTE varchar(10),
									 @ID_MATERIA varchar(10),
									 @CALIFICACION decimal(10,2),
									 @PROMEDIO decimal(10,2),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM REGISTRO_NOTAS WHERE ID_REGISTRO = @ID_REGISTRO))	
					BEGIN
						INSERT INTO REGISTRO_NOTAS(ID_REGISTRO, ID_COMPROBANTE, ID_MATERIA, CALIFICACION, PROMEDIO)
							VALUES(@ID_REGISTRO, @ID_COMPROBANTE, @ID_MATERIA, @CALIFICACION, @PROMEDIO)
						SET @MSJ = 'REGISTRO NOTAS AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL REGISTRO NOTAS YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_REGISTRO_NOTAS(@ID_REGISTRO varchar(10),
									 @ID_COMPROBANTE varchar(10),
									 @ID_MATERIA varchar(10),
									 @CALIFICACION decimal(10,2),
									 @PROMEDIO decimal(10,2),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM REGISTRO_NOTAS WHERE ID_REGISTRO = @ID_REGISTRO))	
					BEGIN
						DELETE FROM REGISTRO_NOTAS WHERE ID_REGISTRO = @ID_REGISTRO
						SET @MSJ = 'REGISTRO NOTAS BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL REGISTRO DE NOTAS NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_REGISTRO_NOTAS(@ID_REGISTRO varchar(10),
									 @ID_COMPROBANTE varchar(10),
									 @ID_MATERIA varchar(10),
									 @CALIFICACION decimal(10,2),
									 @PROMEDIO decimal(10,2),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM REGISTRO_NOTAS WHERE ID_REGISTRO = @ID_REGISTRO))	
					BEGIN
						UPDATE REGISTRO_NOTAS SET
							ID_REGISTRO = @ID_REGISTRO,
							ID_COMPROBANTE = @ID_COMPROBANTE,
							ID_MATERIA = @ID_MATERIA,
							CALIFICACION = @CALIFICACION,
							PROMEDIO = @PROMEDIO
						WHERE ID_REGISTRO = @ID_REGISTRO
						SET @MSJ = 'REGISTRO NOTAS ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL REGISTRO DE NOTAS NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA FACTURAS ***********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_FACTURAS(@ID_FACTURA varchar(10),
									 @ID_COMPROBANTE varchar(10),
									 @MONTOTOTAL decimal(10,2),
									 @DETALLES varchar(200),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM FACTURAS WHERE ID_FACTURA = @ID_FACTURA))	
					BEGIN
						INSERT INTO FACTURAS(ID_FACTURA, ID_COMPROBANTE, MONTOTOTAL, DETALLES)
							VALUES(@ID_FACTURA, @ID_COMPROBANTE, @MONTOTOTAL, @DETALLES)
						SET @MSJ = 'FACTURA AGREGADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA FACTURA YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_FACTURAS(@ID_FACTURA varchar(10),
									 @ID_COMPROBANTE varchar(10),
									 @MONTOTOTAL decimal(10,2),
									 @DETALLES varchar(200),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM FACTURAS WHERE ID_FACTURA = @ID_FACTURA))	
					BEGIN
						DELETE FROM FACTURAS WHERE ID_FACTURA = @ID_FACTURA
						SET @MSJ = 'FACTURA BORRADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA FACTURA NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_FACTURAS(@ID_FACTURA varchar(10),
									 @ID_COMPROBANTE varchar(10),
									 @MONTOTOTAL decimal(10,2),
									 @DETALLES varchar(200),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM FACTURAS WHERE ID_FACTURA = @ID_FACTURA))	
					BEGIN
						UPDATE FACTURAS SET
							ID_FACTURA = @ID_FACTURA,
							ID_COMPROBANTE = @ID_COMPROBANTE,
							MONTOTOTAL = @MONTOTOTAL,
							DETALLES = @DETALLES
						WHERE ID_FACTURA = @ID_FACTURA
						SET @MSJ = 'FACTURA ACTUALIZADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA FACTURA NO SE PUEDE ACTUZLIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA MATERIAS_DISPONIBLES ***********************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_MATERIAS_DISPONIBLES(@ID_MATERIA_ABIERTA varchar(10),
									 @ID_MATERIA varchar(10),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM MATERIAS_DISPONIBLES WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA))	
					BEGIN
						INSERT INTO MATERIAS_DISPONIBLES(ID_MATERIA_ABIERTA, ID_MATERIA)
							VALUES(@ID_MATERIA_ABIERTA, @ID_MATERIA)
						SET @MSJ = 'MATERIA_DISPONIBLE AGREGADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATERIA_DISPONIBLE YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_MATERIAS_DISPONIBLES(@ID_MATERIA_ABIERTA varchar(10),
									 @ID_MATERIA varchar(10),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM MATERIAS_DISPONIBLES WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA))	
					BEGIN
						DELETE FROM MATERIAS_DISPONIBLES WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA
						SET @MSJ = 'MATERIA_DISPONIBLE BORRADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATERIA_DISPONIBLE NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_MATERIAS_DISPONIBLES(@ID_MATERIA_ABIERTA varchar(10),
									 @ID_MATERIA varchar(10),
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM MATERIAS_DISPONIBLES WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA))	
					BEGIN
						UPDATE MATERIAS_DISPONIBLES SET
							ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA,
							ID_MATERIA = @ID_MATERIA
						WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA
						SET @MSJ = 'MATERIA_DISPONIBLE ACTUALIZADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATERIA_DISPONIBLE NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA MATERIAS ***********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_MATERIAS(@ID_MATERIA varchar(10),
									 @ID_CARRERA varchar(10),
									 @ID_PROFESOR_CERTIFICADO varchar(10),
									 @NOMBRE varchar(60),
									 @HORAS int,
									 @COSTO decimal(10,2),
									 @CREDITOS smallint,
									 @REQUISITOS varchar(10),
									 @DETALLES varchar(200),
									 @ESTADO varchar(3),
									 @BORRADO_M bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM MATERIAS WHERE ID_MATERIA = @ID_MATERIA))	
					BEGIN
						INSERT INTO MATERIAS(ID_MATERIA, ID_CARRERA, ID_PROFESOR_CERTIFICADO, NOMBRE, HORAS, COSTO, CREDITOS, REQUISITOS, DETALLES, ESTADO, BORRADO_M)
							VALUES(@ID_MATERIA, @ID_CARRERA, @ID_PROFESOR_CERTIFICADO, @NOMBRE, @HORAS, @COSTO, @CREDITOS, @REQUISITOS, @DETALLES, @ESTADO, @BORRADO_M)
						SET @MSJ = 'MATERIA AGREGADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATERIA YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_MATERIAS(@ID_MATERIA varchar(10),
									 @ID_CARRERA varchar(10),
									 @ID_PROFESOR_CERTIFICADO varchar(10),
									 @NOMBRE varchar(60),
									 @HORAS int,
									 @COSTO decimal(10,2),
									 @CREDITOS smallint,
									 @REQUISITOS varchar(10),
									 @DETALLES varchar(200),
									 @ESTADO varchar(3),
									 @BORRADO_M bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM MATERIAS WHERE ID_MATERIA = @ID_MATERIA))	
					BEGIN
						DELETE FROM MATERIAS WHERE ID_MATERIA = @ID_MATERIA
						SET @MSJ = 'MATERIA BORRADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATERIA NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_MATERIAS(@ID_MATERIA varchar(10),
									 @ID_CARRERA varchar(10),
									 @ID_PROFESOR_CERTIFICADO varchar(10),
									 @NOMBRE varchar(60),
									 @HORAS int,
									 @COSTO decimal(10,2),
									 @CREDITOS smallint,
									 @REQUISITOS varchar(10),
									 @DETALLES varchar(200),
									 @ESTADO varchar(3),
									 @BORRADO_M bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM MATERIAS WHERE ID_MATERIA = @ID_MATERIA))	
					BEGIN
						UPDATE MATERIAS SET
							ID_MATERIA = @ID_MATERIA,
							ID_CARRERA = @ID_CARRERA,
							ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO,
							NOMBRE = @NOMBRE,
							HORAS = @HORAS,
							COSTO = @COSTO,
							CREDITOS = @CREDITOS,
							REQUISITOS = @REQUISITOS,
							DETALLES = @DETALLES,
							ESTADO = @ESTADO,
							BORRADO_M = @BORRADO_M
						WHERE ID_MATERIA = @ID_MATERIA
						SET @MSJ = 'MATERIA ACTUALIZADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA MATERIA NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA CARRERAS ***********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_CARRERAS(@ID_CARRERA varchar(10),
									 @NOMBRE varchar(60),
									 @GRADO varchar(30),
									 @DESCRIPCION varchar(200),
									 @TOTAL_CREDITOS smallint,
									 @BORRADO_C bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM CARRERAS WHERE ID_CARRERA = @ID_CARRERA))	
					BEGIN
						INSERT INTO CARRERAS(ID_CARRERA, NOMBRE, GRADO, DESCRIPCION, TOTAL_CREDITOS, BORRADO_C)
							VALUES(@ID_CARRERA, @NOMBRE, @GRADO, @DESCRIPCION, @TOTAL_CREDITOS, @BORRADO_C)
						SET @MSJ = 'CARRERA AGREGADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA CARRERA YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_CARRERAS(@ID_CARRERA varchar(10),
									 @NOMBRE varchar(60),
									 @GRADO varchar(30),
									 @DESCRIPCION varchar(200),
									 @TOTAL_CREDITOS smallint,
									 @BORRADO_C bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM CARRERAS WHERE ID_CARRERA = @ID_CARRERA))	
					BEGIN
						DELETE FROM CARRERAS WHERE ID_CARRERA = @ID_CARRERA
						SET @MSJ = 'CARRERA BORRADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA CARRERA NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_CARRERAS(@ID_CARRERA varchar(10),
									 @NOMBRE varchar(60),
									 @GRADO varchar(30),
									 @DESCRIPCION varchar(200),
									 @TOTAL_CREDITOS smallint,
									 @BORRADO_C bit,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM CARRERAS WHERE ID_CARRERA = @ID_CARRERA))	
					BEGIN
						UPDATE CARRERAS SET
							ID_CARRERA = @ID_CARRERA,
							NOMBRE = @NOMBRE,
							GRADO = @GRADO,
							DESCRIPCION = @DESCRIPCION,
							TOTAL_CREDITOS = @TOTAL_CREDITOS,
							BORRADO_C = @BORRADO_C
						WHERE ID_CARRERA = @ID_CARRERA
						SET @MSJ = 'CARRERA ACTUALIZADA SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'LA CARRERA NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA GRUPOS *************************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_GRUPOS(@ID_GRUPO varchar(10),
									 @ID_MATERIA_ABIERTA varchar(10),
									 @ID_LABORATORIO varchar(10),
									 @CUPO smallint,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO))	
					BEGIN
						INSERT INTO GRUPOS(ID_GRUPO, ID_MATERIA_ABIERTA, ID_LABORATORIO, CUPO)
							VALUES(@ID_GRUPO, @ID_MATERIA_ABIERTA, @ID_LABORATORIO, @CUPO)
						SET @MSJ = 'GRUPO AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL GRUPO YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_GRUPOS(@ID_GRUPO varchar(10),
									 @ID_MATERIA_ABIERTA varchar(10),
									 @ID_LABORATORIO varchar(10),
									 @CUPO smallint,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO))	
					BEGIN
						DELETE FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO
						SET @MSJ = 'GRUPO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL GRUPO NO SE PUEDE BORRAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_GRUPOS(@ID_GRUPO varchar(10),
									 @ID_MATERIA_ABIERTA varchar(10),
									 @ID_LABORATORIO varchar(10),
									 @CUPO smallint,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO))	
					BEGIN
						UPDATE GRUPOS SET
							ID_GRUPO = @ID_GRUPO,
							ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA,
							ID_LABORATORIO = @ID_LABORATORIO,
							CUPO = @CUPO
						WHERE ID_GRUPO = @ID_GRUPO
						SET @MSJ = 'GRUPO ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL GRUPO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA LABORATORIOS *******************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_LABORATORIOS(@ID_LABORATORIO varchar(10),
									 @PABELLON smallint,
									 @CANTIDAD_LAPTOPS smallint,
									 @CANTIDAD_SILLAS smallint,
									 @CANTIDAD_ESCRITORIOS smallint,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM LABORATORIOS WHERE ID_LABORATORIO = @ID_LABORATORIO))	
					BEGIN
						INSERT INTO LABORATORIOS(ID_LABORATORIO, PABELLON, CANTIDAD_LAPTOPS, CANTIDAD_SILLAS, CANTIDAD_ESCRITORIOS)
							VALUES(@ID_LABORATORIO, @PABELLON, @CANTIDAD_LAPTOPS, @CANTIDAD_SILLAS, @CANTIDAD_ESCRITORIOS)
						SET @MSJ = 'LABORATORIO AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL LABORATORIO YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_LABORATORIOS(@ID_LABORATORIO varchar(10),
									 @PABELLON smallint,
									 @CANTIDAD_LAPTOPS smallint,
									 @CANTIDAD_SILLAS smallint,
									 @CANTIDAD_ESCRITORIOS smallint,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM LABORATORIOS WHERE ID_LABORATORIO = @ID_LABORATORIO))	
					BEGIN
						DELETE FROM LABORATORIOS WHERE ID_LABORATORIO = @ID_LABORATORIO
						SET @MSJ = 'LABORATORIO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL LABORATORIO NO SE PUEDE BORRAR PORQUE NO EXISTE'					
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_LABORATORIOS(@ID_LABORATORIO varchar(10),
									 @PABELLON smallint,
									 @CANTIDAD_LAPTOPS smallint,
									 @CANTIDAD_SILLAS smallint,
									 @CANTIDAD_ESCRITORIOS smallint,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM LABORATORIOS WHERE ID_LABORATORIO = @ID_LABORATORIO))	
					BEGIN
						UPDATE LABORATORIOS SET
							ID_LABORATORIO = @ID_LABORATORIO,
							PABELLON = @PABELLON,
							CANTIDAD_LAPTOPS = @CANTIDAD_LAPTOPS,
							CANTIDAD_SILLAS = @CANTIDAD_SILLAS,
							CANTIDAD_ESCRITORIOS = @CANTIDAD_ESCRITORIOS
						WHERE ID_LABORATORIO = @ID_LABORATORIO
						SET @MSJ = 'LABORATORIO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL LABORATORIO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'					
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA HORARIOS ***********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_HORARIOS(@ID_GRUPO varchar(10),
									 @DIA varchar(1),
									 @HORAINICIO time,
									 @HORAFIN time,
									 @F_INICIO date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO))	
					BEGIN
						INSERT INTO HORARIOS (ID_GRUPO, DIA, HORAINICIO, HORAFIN, F_INICIO)
							VALUES(@ID_GRUPO, @DIA, @HORAINICIO, @HORAFIN, @F_INICIO)
						SET @MSJ = 'HORARIO AGREGADO SATISFACTORIAMENTE'
					END
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_HORARIOS(@ID_GRUPO varchar(10),
									 @DIA varchar(1),
									 @HORAINICIO time,
									 @HORAFIN time,
									 @F_INICIO date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO))	
					BEGIN
						DELETE FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO
						SET @MSJ = 'HORARIO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL HORARIO NO SE PUEDE BORRAR PORQUE NO EXISTE'					
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_HORARIOS(@ID_GRUPO varchar(10),
									 @DIA varchar(1),
									 @HORAINICIO time,
									 @HORAFIN time,
									 @F_INICIO date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO))	
					BEGIN
						UPDATE HORARIOS SET
							ID_GRUPO = @ID_GRUPO,
							DIA = @DIA,
							HORAINICIO = @HORAINICIO,
							HORAFIN = @HORAFIN,
							F_INICIO = @F_INICIO
						WHERE ID_GRUPO = @ID_GRUPO
						SET @MSJ = 'HORARIO ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL HORARIO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'					
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--TABLA FERIADOS ***********************************************************************
--INSERTAR..............................................................................
GO
CREATE OR ALTER PROCEDURE SP_INSERTAR_FERIADOS(@ID_FERIADO int OUT,
									 @ID_GRUPO varchar(10),
									 @FECHA date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (NOT EXISTS(SELECT 1 FROM FERIADOS WHERE ID_FERIADO = @ID_FERIADO))	
					BEGIN
						INSERT INTO FERIADOS (ID_GRUPO, FECHA)
							VALUES (@ID_GRUPO, @FECHA)
						SELECT @ID_FERIADO = IDENT_CURRENT('FERIADOS') --SE DEFINE EL IDENTITY
						SET @MSJ = 'FERIADO AGREGADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL FERIADO YA EXISTE'
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--BORRAR................................................................................
GO
CREATE OR ALTER PROCEDURE SP_BORRAR_FERIADOS(@ID_FERIADO int OUT,
									 @ID_GRUPO varchar(10),
									 @FECHA date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM FERIADOS WHERE ID_FERIADO = @ID_FERIADO))	
					BEGIN
						DELETE FROM FERIADOS WHERE ID_FERIADO = @ID_FERIADO
						SET @MSJ = 'FERIADO BORRADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL FERIADO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'					
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--ACTUALIZAR............................................................................
GO
CREATE OR ALTER PROCEDURE SP_ACTUALIZAR_FERIADOS(@ID_FERIADO int,
									 @ID_GRUPO varchar(10),
									 @FECHA date,
									 @MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION
			BEGIN
				IF (EXISTS(SELECT 1 FROM FERIADOS WHERE ID_FERIADO = @ID_FERIADO))	
					BEGIN
						UPDATE FERIADOS SET
							ID_GRUPO = @ID_GRUPO,
							FECHA = @FECHA
						WHERE ID_FERIADO = @ID_FERIADO
						SET @MSJ = 'FERIADO ACTUALIZADO SATISFACTORIAMENTE'
					END
				ELSE
					SET @MSJ = 'EL FERIADO NO SE PUEDE ACTUALIZAR PORQUE NO EXISTE'					
			END
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--**************************************************************************************
--FUNCIONES ****************************************************************************

--1. FUNCION QUE VERIFICA SI UN PROFESOR ESTÁ CERTIFICADO O NO
GO
CREATE OR ALTER FUNCTION F_BUSCAR_CERTIFICADO_PROFESOR(@ID_PROFESOR varchar(15))
RETURNS INT AS

BEGIN
	--DECLARAN LAS VARIABLES
	DECLARE @CERTIFICADO INT

	--SI EXISTE EN PROFESORES CERTIFICADOS EL PROFESOR QUE INGRESA EN LOS PARAMETROS, VERIFICA SEGUN EL ID_PROFESOR
	IF (EXISTS(SELECT 1 FROM PROFESORES_CERTIFICADOS PC INNER JOIN PROFESORES P
		ON PC.ID_PROFESOR = P.ID_PROFESOR
		WHERE P.ID_PROFESOR = @ID_PROFESOR))
		SET @CERTIFICADO = 1 --SI ESTÁ CERTIFICADO
	ELSE
		SET @CERTIFICADO = 0 --NO LO ESTÁ

	RETURN @CERTIFICADO
END
GO

--PRUEBAS ----------------------
IF (SELECT dbo.F_BUSCAR_CERTIFICADO_PROFESOR('PRO-MAA99')) = 1
	PRINT 'SI ESTA CERTIFICADO'

SELECT P.ID_PROFESOR
	FROM PROFESORES P INNER JOIN PROFESORES_CERTIFICADOS PC
	ON P.ID_PROFESOR = PC.ID_PROFESOR

	INNER JOIN CERTIFICACIONES C
	ON PC.ID_CERTIFICADO = C.ID_CERTIFICADO
	WHERE P.ID_PROFESOR = 'PRO-MAA99'

SELECT * FROM PROFESORES

----------------------------------------------------------------------------------------
--2. FUNCION SUMA EL COSTO DE LAS MATERIAS MATRICULADAS POR ESTUDIANTE
GO
CREATE OR ALTER FUNCTION F_SUMAR_COSTO_MATERIAS(@ID_ESTUDIANTE varchar(10))
RETURNS DECIMAL(10,2) AS

BEGIN
	--DECLARAN LAS VARIABLES
	DECLARE @TOTAL decimal(10,2)

	--SUMA EL COSTO DE CADA MATERIA MATRICULADA POR EL ESTUDIANTE, VERIFICANDO SEGUN EL ID
	SET @TOTAL = (SELECT SUM(COSTO)
		FROM MATERIAS M INNER JOIN REGISTRO_NOTAS RN
		ON M.ID_MATERIA = RN.ID_MATERIA
		
		INNER JOIN MATRICULAS MA
		ON RN.ID_COMPROBANTE = MA.ID_COMPROBANTE
		WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE)
	RETURN @TOTAL
END
GO

--PRUEBAS ----------------------
SELECT dbo.F_SUMAR_COSTO_MATERIAS('MCA0123')

SELECT * FROM ESTUDIANTES
SELECT * FROM MATRICULAS
SELECT * FROM REGISTRO_NOTAS
SELECT * FROM MATERIAS

----------------------------------------------------------------------------------------
--3. FUNCION REVISA QUE LA CANTIDAD DE HORAS DE CLASE CORRESPONDA ENTRE 2 A 5

GO
CREATE OR ALTER FUNCTION F_CALCULA_CANT_HORAS_CLASE(@HORAINICIO time,
													 @HORAFIN time)
RETURNS INT AS

BEGIN
	--DECLARAN LAS VARIABLES
	DECLARE @CANTIDAD_HORAS INT
	
	--SI LA CANTIDA DE HORAS QUE EXISTEN ENTRE LA HORA DE INICIO Y FIN ES MENOR O IGUAL 5 Y MAYOR O IGUAL A 2
	IF((DATEDIFF(HOUR, @HORAINICIO, @HORAFIN) <= 5) AND (DATEDIFF(HOUR, @HORAINICIO, @HORAFIN) >= 2))
		SET @CANTIDAD_HORAS = 1 
	ELSE --SI ES MENOR A 2 O MAYOR A 5 
		SET @CANTIDAD_HORAS = 0
	RETURN @CANTIDAD_HORAS
END
GO

----------------------------------------------------------------------------------------
--4. FUNCION QUE VERIFICA QUE HAYA APROBADO LOS CURSOS POSTERIORES
GO
CREATE OR ALTER FUNCTION F_VERIFICAR_REQUISITOS_MATERIA(@ID_ESTUDIANTE varchar(10), 
														@ID_MATERIA_ABIERTA varchar(10))
RETURNS INT AS

BEGIN
	--DECLARAN VARIABLES
	DECLARE @CUMPLE INT,
		 @ID_MATERIA VARCHAR(10),
		 @ID_MATERIA_ANTERIOR VARCHAR(10),
		 @NOTA DECIMAL(10,2)


	SET @CUMPLE = 0
	
	--SE ASIGNA EN LA VARIABLE EL VALOR DEL ID DE LA MATERIA ABIERTA QUE INGRESA POR PARAMETRO
	SET @ID_MATERIA = (SELECT M.ID_MATERIA
					   FROM MATERIAS  M INNER JOIN MATERIAS_DISPONIBLES MD
					   ON M.ID_MATERIA = MD.ID_MATERIA
					   WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA)

	--SE ASIGNA EN LA VARIABLE EL VALOR DE LA MATERIA ANTERIOR ES DECIR DEL REQUISITO
	SET @ID_MATERIA_ANTERIOR = (SELECT DISTINCT REQUISITOS
								FROM MATERIAS M						
								WHERE M.ID_MATERIA = @ID_MATERIA)
	
	--SE ASIGNA EN LA VARIABLE LA CALIFICACION QUE TUVO EL ESTUDIANTE EN LA MATERIA ANTERIOR PARA DETERMINAR SI APROBÓ
	SET @NOTA = (SELECT CALIFICACION
				FROM MATERIAS M INNER JOIN REGISTRO_NOTAS RN
				ON M.ID_MATERIA = RN.ID_MATERIA

				INNER JOIN MATRICULAS MAT
				ON RN.ID_COMPROBANTE = MAT.ID_COMPROBANTE

				WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE AND M.ID_MATERIA = @ID_MATERIA_ANTERIOR)
	
	--SI LA NOTA ES MAYOR O IGUAL A 70 O SI NO CUENTA CON REQUISITOS
	IF (@NOTA >= 70 OR @ID_MATERIA_ANTERIOR = 'NO APLICA')
		SET @CUMPLE = 1
	ELSE --SI NO LOS CUMPLE
		SET @CUMPLE = 0

	RETURN @CUMPLE
END

GO

--PRUEBAS ----------------------
IF (SELECT dbo.F_VERIFICAR_REQUISITOS_MATERIA('KGH0321', 'PAWE_JS')) = 1
	PRINT 'APROBÓ LA MATERIA ANTERIOR'

INSERT INTO MATRICULAS(ID_COMPROBANTE, ID_ESTUDIANTE, ID_MATERIA_ABIERTA, NOTAPONDERADA, DESCUENTO, DETALLES)
	VALUES('C12', 'KGH0321', 'A_PAWE_HT', 95.9, 0, 'SIN DETALLES')

INSERT INTO REGISTRO_NOTAS(ID_REGISTRO, ID_COMPROBANTE, ID_MATERIA, CALIFICACION, PROMEDIO)
	VALUES('N-11', 'C11', 'PAWE_CS', 91.9, 88.9)

SELECT * FROM ESTUDIANTES
SELECT * FROM REGISTRO_NOTAS
SELECT * FROM MATERIAS 
SELECT * FROM MATRICULAS ORDER BY ID_ESTUDIANTE

----------------------------------------------------------------------------------------
--5. FUNCION REVISA HORARIOS ESTUDIANTES PARA DETERMINAR SI HAY CHOQUE DE HORARIOS ENTRE MATERIAS
GO
CREATE OR ALTER FUNCTION F_CHOQUE_HORARIOS_ESTUDIANTES(@ID_ESTUDIANTE VARCHAR(10),
							    @DIA VARCHAR(1),
								@INICIO TIME,
								@FIN TIME)
RETURNS INT AS

BEGIN
	--DECLARAN LAS VARIABLES
	DECLARE @CHOQUE INT

	SET @CHOQUE = 0
	
	--VERIFICA SI EL ESTUDIANTE DE LA VARIABLE QUE SE RECIBE EXISTE
	IF (EXISTS(SELECT 1 FROM HORARIOS H INNER JOIN GRUPOS G
				ON H.ID_GRUPO = G.ID_GRUPO
			
				INNER JOIN MATERIAS_DISPONIBLES MD
				ON G.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA
			
				INNER JOIN MATRICULAS M
				ON MD. ID_MATERIA_ABIERTA = M.ID_MATERIA_ABIERTA
				WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE))
		BEGIN --SI EXISTE EL ESTUDIANTE

			--DECLARAN VARIABLES PARA EL CURSOR
			DECLARE @DIA_CLASE VARCHAR(1),
					@H_INICIO TIME,
					@H_FIN TIME

			--1.DECLARAR CURSOR CON EL ID DE LOS ESTUDIATES
			DECLARE VERIFICAR_HORARIO CURSOR
			FOR
				(SELECT DIA, HORAINICIO, HORAFIN
				FROM HORARIOS H INNER JOIN GRUPOS G
				ON H.ID_GRUPO = G.ID_GRUPO
			
				INNER JOIN MATERIAS_DISPONIBLES MD
				ON G.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA
			
				INNER JOIN MATRICULAS M
				ON MD. ID_MATERIA_ABIERTA = M.ID_MATERIA_ABIERTA
				WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE)

			--2.ABRIR CURSOR
			OPEN VERIFICAR_HORARIO

			--3.NAVEGAR
			FETCH VERIFICAR_HORARIO INTO @DIA_CLASE, @H_INICIO, @H_FIN

			WHILE(@@FETCH_STATUS = 0)
				BEGIN
					IF(@DIA = @DIA_CLASE) --SI EL DIA DE CLASE ES IGUAL AL DIA DE LA VARIABLE SE INGRESÓ
						IF(((@H_FIN BETWEEN @INICIO AND @FIN) AND (@H_INICIO BETWEEN @INICIO AND @FIN)) OR --SI LA HORA QUE INICIA SE ENCUENTRA ENTRE LA HORA DE INCIO Y FINAL QUE SE INGRESÓ
						   ((@H_FIN BETWEEN @INICIO AND @FIN) OR (@H_INICIO BETWEEN @INICIO AND @FIN))) --SI LA HORA QUE TERMINA SE ENCUENTRA ENTRE LA HORA DE INCIO Y FINAL QUE SE INGRESÓ
							BEGIN
								SET @CHOQUE = 1
							END
					FETCH VERIFICAR_HORARIO INTO @DIA_CLASE, @H_INICIO, @H_FIN --PARA CONTINUAR NAVEGANDO EN EL CURSOR
				END

			--4.CERRAR CURSOR
			CLOSE VERIFICAR_HORARIO

			--5.LIBERAR
			DEALLOCATE VERIFICAR_HORARIO
		END
		RETURN @CHOQUE
END
GO

--PRUEBAS ----------------------
IF (SELECT dbo.F_CHOQUE_HORARIOS_ESTUDIANTES('PHV0812', 'V', '15:00', '16:00')) = 1 --1 CHOQUE (MUESTRA NOMBRE) | 0 NO 
	PRINT 'HAY CHOQUE DE HORARIOS'

SELECT ID_GRUPO
FROM ESTUDIANTES E INNER JOIN MATRICULAS M
ON E.ID_ESTUDIANTE = M.ID_ESTUDIANTE

INNER JOIN MATERIAS_DISPONIBLES MD
ON M.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA

INNER JOIN GRUPOS G
ON MD.ID_MATERIA_ABIERTA = G.ID_MATERIA_ABIERTA
WHERE E.ID_ESTUDIANTE = 'PHV0812'

SELECT * FROM ESTUDIANTES
SELECT * FROM HORARIOS

-------------------------------------------------------------------------------------------------------
--6. FUNCION REVISA HORARIOS PROFESORES PARA DETERMINAR SI HAY CHOQUE DE HORARIOS
GO
CREATE OR ALTER FUNCTION F_CHOQUE_HORARIOS_PROFESORES(@ID_PROFESOR VARCHAR(10),
							    @DIA VARCHAR(1),
								@INICIO TIME,
								@FIN TIME)
RETURNS INT AS

BEGIN
	--DECLARAN LAS VARIABLES
	DECLARE @CHOQUE INT
	SET @CHOQUE = 0

	--VERIFICA SI EL PROFESOR DE LA VARIABLE QUE SE RECIBE EXISTE	
	IF (EXISTS(SELECT 1 FROM HORARIOS H INNER JOIN GRUPOS G
				ON H.ID_GRUPO = G.ID_GRUPO
			
				INNER JOIN MATERIAS_DISPONIBLES MD
				ON G.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA
			
				INNER JOIN MATERIAS M
				ON MD.ID_MATERIA = M.ID_MATERIA

				INNER JOIN PROFESORES_CERTIFICADOS PC
				ON M.ID_PROFESOR_CERTIFICADO = PC.ID_PROFESOR_CERTIFICADO

				INNER JOIN PROFESORES P
				ON PC.ID_PROFESOR = P.ID_PROFESOR
				WHERE P.ID_PROFESOR = @ID_PROFESOR))
		BEGIN --SI EXISTE

			--DECLARAN VARIABLES PARA EL CURSOR			
			DECLARE @DIA_CLASE VARCHAR(1),
					@H_INICIO TIME,
					@H_FIN TIME	

			--1.DECLARAR CURSOR CON EL DIA HORA INCIO Y FIN DE LAS MATERIAS QUE IMPARTE
			DECLARE VERIFICAR_HORARIO CURSOR
			FOR
				(SELECT DIA, HORAINICIO, HORAFIN
				FROM HORARIOS H INNER JOIN GRUPOS G
				ON H.ID_GRUPO = G.ID_GRUPO
			
				INNER JOIN MATERIAS_DISPONIBLES MD
				ON G.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA
			
				INNER JOIN MATERIAS M
				ON MD.ID_MATERIA = M.ID_MATERIA

				INNER JOIN PROFESORES_CERTIFICADOS PC
				ON M.ID_PROFESOR_CERTIFICADO = PC.ID_PROFESOR_CERTIFICADO

				INNER JOIN PROFESORES P
				ON PC.ID_PROFESOR = P.ID_PROFESOR
				WHERE P.ID_PROFESOR = @ID_PROFESOR)

			--2.ABRIR CURSOR
			OPEN VERIFICAR_HORARIO

			--3.NAVEGAR
			FETCH VERIFICAR_HORARIO INTO @DIA_CLASE, @H_INICIO, @H_FIN

			WHILE(@@FETCH_STATUS = 0)
				BEGIN
					IF(@DIA = @DIA_CLASE) --SI EL DIA DE CLASE ES IGUAL AL DIA DE LA VARIABLE SE INGRESÓ
						IF(((@H_FIN BETWEEN @INICIO AND @FIN) AND (@H_INICIO BETWEEN @INICIO AND @FIN)) OR --SI LA HORA QUE INICIA SE ENCUENTRA ENTRE LA HORA DE INCIO Y FINAL QUE SE INGRESÓ
						   ((@H_FIN BETWEEN @INICIO AND @FIN) OR (@H_INICIO BETWEEN @INICIO AND @FIN))) --SI LA HORA QUE TERMINA SE ENCUENTRA ENTRE LA HORA DE INCIO Y FINAL QUE SE INGRESÓ
							BEGIN
								SET @CHOQUE = 1
							END
					FETCH VERIFICAR_HORARIO INTO @DIA_CLASE, @H_INICIO, @H_FIN --PARA CONTINUAR NAVEGANDO EN EL CURSOR
				END

			--4.CERRAR CURSOR
			CLOSE VERIFICAR_HORARIO

			--5.LIBERAR
			DEALLOCATE VERIFICAR_HORARIO
		END
		RETURN @CHOQUE
END
GO

--PRUEBAS ----------------------
IF (SELECT dbo.F_CHOQUE_HORARIOS_PROFESORES('PRO-PVL93', 'L', '14:00', '18:00')) = 1 --1 CHOQUE (MUESTRA NOMBRE) | 0 NO 
	PRINT 'HAY CHOQUE DE HORARIOS'

SELECT DIA, HORAINICIO, HORAFIN
	FROM HORARIOS H INNER JOIN GRUPOS G
	ON H.ID_GRUPO = G.ID_GRUPO
			
	INNER JOIN MATERIAS_DISPONIBLES MD
	ON G.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA
			
	INNER JOIN MATERIAS M
	ON MD.ID_MATERIA = M.ID_MATERIA

	INNER JOIN PROFESORES_CERTIFICADOS PC
	ON M.ID_PROFESOR_CERTIFICADO = PC.ID_PROFESOR_CERTIFICADO

	INNER JOIN PROFESORES P
	ON PC.ID_PROFESOR = P.ID_PROFESOR
	WHERE P.ID_PROFESOR = 'PRO-PVL93'

SELECT * FROM PROFESORES

----------------------------------------------------------------------------------------
--7. FUNCION CALCULAR FECHA DE FINALIZACION DEL CURSO
GO
CREATE OR ALTER FUNCTION F_CALCULA_FECHA_FIN(@ID_GRUPO varchar(10),
									@ID_MATERIA_DISPONIBLE varchar(10),
									@F_INICIO date)
RETURNS DATE AS

BEGIN
	--DECLARAN VARIABLES
	DECLARE @F_FIN DATE
	DECLARE @HORAS_POR_SEMANA INT
	DECLARE @TOTAL_HORAS INT
	DECLARE @CANT_SEMANAS DECIMAL(10,2)

	--ASIGNA A LA VARIABLE LA CANTIDAD DE HORAS EN TOTAL QUE DURA EL MODULO
	SET @TOTAL_HORAS = (SELECT HORAS --TOTAL HORAS POR MATERIA
		FROM MATERIAS M INNER JOIN MATERIAS_DISPONIBLES MD
		ON M.ID_MATERIA = MD.ID_MATERIA
		WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_DISPONIBLE) 

	--ASIGNA LA CANTIDAD DE HORAS DE CLASES POR SEMANA A LA VARIABLE
	SET @HORAS_POR_SEMANA = (SELECT DISTINCT SUM(DATEDIFF(HOUR, HORAINICIO, HORAFIN)) --CALCULA LAS HORAS DESDE EL INCIO HASTA EL FIN
		FROM HORARIOS H INNER JOIN GRUPOS G
		ON H.ID_GRUPO = G.ID_GRUPO

		INNER JOIN MATERIAS_DISPONIBLES MD
		ON G.ID_MATERIA_ABIERTA = MD.ID_MATERIA_ABIERTA
		WHERE MD.ID_MATERIA_ABIERTA = @ID_MATERIA_DISPONIBLE)

	--ASIGNA LAS CANTIDAD DE SEMANAS DIVIDDIENDO EL TOTAL DEL MODULO ENTRE LAS HORAS POR SEMANA
	SET @CANT_SEMANAS = @TOTAL_HORAS / @HORAS_POR_SEMANA 

	--ASIGNA A LA VARIABLE LA FECHA DE INICIO SUMANDOLE LA CANTIDAD DE SEMANAS
	SET @F_FIN = DATEADD(WEEK, @CANT_SEMANAS, @F_INICIO)

	RETURN @F_FIN	
END

GO

--PRUEBA------------------------
SELECT dbo.F_CALCULA_FECHA_FIN('G1_PAWEBS', 'A_PAWE_BS', GETDATE())

SELECT * FROM HORARIOS
SELECT * FROM MATERIAS_DISPONIBLES

----------------------------------------------------------------------------------------
--8. FUNCION QUE BUSCA LA CAPACIDAD QUE TIENEN LOS LABORATORIOS PARA DETERMINAR SI ES APTO
--PARA UN GRUPO SEGUN EL CUPO

GO 
CREATE OR ALTER FUNCTION F_CAPACIDAD_LABORATORIO(@ID_LABORATORIO varchar(10),
										@ID_GRUPO varchar(10))
RETURNS INT AS

BEGIN
	
	--DECLARAN VARIABLES
	DECLARE @CAPACIDAD INT,
			@ADECUADA INT,
			@CUPO INT

	--SE LE ASIGNA A LA VARIABLE EL CUPO CON EL QUE CUENTA EL GRUPO DE LA VARIABLE QUE SE RECIBE
	SET @CUPO = (SELECT CUPO
				FROM GRUPOS
				WHERE ID_GRUPO = @ID_GRUPO)

	--SE LE ASIGNA A LA VARIABLE UN PROMEDIO SEGUN LA CANTIDAD DE SILLAS, LAPTOPS Y ESCRITORIOS QUE CONTIENE EL LABORATORIO CORRESPONDIENTE
	SET @CAPACIDAD = (SELECT FLOOR(AVG((CANTIDAD_LAPTOPS + CANTIDAD_SILLAS + CANTIDAD_ESCRITORIOS) / 3))
					  FROM LABORATORIOS L INNER JOIN GRUPOS G
					  ON L.ID_LABORATORIO = G.ID_LABORATORIO
					  WHERE ID_GRUPO = @ID_GRUPO)
	
	--VERIFICA SI LA CAPACIDAD DEL LABORATORIO ES MAYOR O IGUAL AL CUPO, SI ES ADECUADO
	IF @CAPACIDAD >= @CUPO
		SET @ADECUADA = 1
	ELSE --NO ES ADECUADO
		SET @ADECUADA = 0

	RETURN @ADECUADA
END
GO

--EJECUCION --------------------
IF (SELECT (dbo.F_CAPACIDAD_LABORATORIO('LAB01-01', 'G1_DIMOA2'))) = 1
	PRINT 'LA CAPACIDAD ES ADECUADA'
ELSE
	PRINT 'LA CAPACIDAD DEL LABORATORIO NO ES ADECUADA'

SELECT * FROM LABORATORIOS
SELECT * FROM GRUPOS

 ---------------------------------------------------------------------------------------
 --9. FUNCION QUE VERIFICA SI EL ESTUDIANTE ESTA MOROSO CON EL PAGO DE LA MATRICULA
 GO
 CREATE OR ALTER FUNCTION F_VERIFICAR_ESTUDIANTE_MOROSO(@ID_ESTUDIANTE varchar(10))

 RETURNS INT AS

 BEGIN
	--SE DECLARAN VARIABLES
	DECLARE @MOROSO int
	
	--SI EL ESTADO DE LA FACTURA ES MOR (MOROSO) 
	IF (SELECT DISTINCT F.ESTADO 
		FROM FACTURAS F INNER JOIN MATRICULAS M
		ON F.ID_COMPROBANTE = M.ID_COMPROBANTE
		WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE) = 'MOR'
		SET @MOROSO = 1
	ELSE --SI SE ENCUENTRA AL DIA CON LOS PAGOS
		SET @MOROSO = 0

	RETURN @MOROSO
 END
 GO

 --EJECUCION-------------------
 IF (SELECT(dbo.F_VERIFICAR_ESTUDIANTE_MOROSO('CSC0300'))) = 1
	PRINT 'MOROSO'

 SELECT * FROM FACTURAS
 SELECT * FROM MATRICULAS

--****************************************************************************************************************************************************************************
--OTROS PROCEDIMIENTOS ALMACENADOS *******************************************************************************************************************************************

--1. PROCEDIMIENTO ALMACENADO QUE ABRE UNA NUEVA MATERIA PARA MATRICULAR
GO
CREATE OR ALTER PROCEDURE SP_ABRIR_MODULO(@ID_MATERIA_ABIERTA varchar(10), 
										 @ID_MATERIA varchar(10), 
										 @ID_PROFESOR varchar(15),
										 @ID_GRUPO varchar(10), 
										 @ID_LABORATORIO varchar(10),
										 @CUPO smallint,
										 @DIA varchar(1), 
										 @HORAINICIO time,
										 @HORAFIN time,
										 @F_INICIO date,
										 @MSJ varchar(300) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION --INCIA TRANSACCION
			IF (NOT EXISTS(SELECT 1 FROM MATERIAS_DISPONIBLES WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA)) --SI NO EXISTE LA MATERIA ABIERTA
				IF (EXISTS(SELECT 1 FROM MATERIAS WHERE ID_MATERIA = @ID_MATERIA)) --SI LA MATERIA EXISTE
					IF (EXISTS(SELECT 1 FROM PROFESORES WHERE ID_PROFESOR = @ID_PROFESOR)) --SI EL PROFESOR A ASIGNAR EXISTE
						IF (SELECT dbo.F_BUSCAR_CERTIFICADO_PROFESOR(@ID_PROFESOR)) = 1 --LLAMA FUNCION VERIFICA SI EL PROFESOR ESTÁ CERTIFICADO (1 SI / 0 NO)
							IF (NOT EXISTS(SELECT 1 FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO)) --SI EL GRUPO NO EXISTE
								IF (EXISTS(SELECT 1 FROM LABORATORIOS WHERE ID_LABORATORIO = @ID_LABORATORIO)) --SI EL LABORATORIO A ASIGNAR EXISTE
									IF(SELECT dbo.F_CAPACIDAD_LABORATORIO(@ID_LABORATORIO, @ID_GRUPO)) = 1 --LLAMA FUNCION VERIFICA SI LA CAPACIDAD DEL LABORATORIO ES SUFICIENTE SEGUN CUPO (1 SI / 0 NO)						
										IF(SELECT dbo.F_CHOQUE_HORARIOS_PROFESORES(@ID_PROFESOR, @DIA, @HORAINICIO, @HORAFIN)) = 0 --LLAMA FUNCION VERIFICA SI EL PROFESOR TIENE CHOQUE DE HORARIOS (1 SI / 0 NO)
											BEGIN									
												INSERT INTO MATERIAS_DISPONIBLES(ID_MATERIA_ABIERTA, ID_MATERIA) --INSERTA LA MATERIA DISPONIBLE 
													VALUES(@ID_MATERIA_ABIERTA, @ID_MATERIA)

												INSERT INTO GRUPOS(ID_GRUPO, ID_MATERIA_ABIERTA, ID_LABORATORIO, CUPO) --INSERTA EN GRUPOS
													VALUES(@ID_GRUPO, @ID_MATERIA_ABIERTA, @ID_LABORATORIO, @CUPO)

												INSERT INTO HORARIOS(ID_GRUPO, DIA, HORAINICIO, HORAFIN, F_INICIO) --INSERTA EN HORARIOS
													VALUES(@ID_GRUPO, @DIA, @HORAINICIO, @HORAFIN, @F_INICIO)

												SET @MSJ = 'MATERIA ABIERTA SATISFACTORIAMENTE'

											END
										ELSE --SI EL LAB. NO CUENTA CON LA CAPACIDAD
											SET @MSJ = 'SE DIO UN CHOQUE EN EL HORARIO DEL PROFESOR'
									ELSE --SI EL PROFESOR TIENE CHOQUE DE HORARIOS
										SET @MSJ = 'LA CAPACIDAD DEL LABORATORIO ES INSUFICENTE'
								ELSE --SI EL LAB. NO EXISTE
									SET @MSJ = 'EL LABORATORIO INGRESADO NO EXISTE'
							ELSE --SI EL GRUPO YA EXISTE
								SET @MSJ = 'EL GRUPO INDICADO YA EXISTE'
						ELSE --SI EL PROFESOR NO ESTÁ CERTIFICADO
							SET @MSJ = 'EL PROFESOR INDICADO NO ESTÁ CERTIFICADO'
					ELSE --SI EL PROFESOR NO EXISTE
						SET @MSJ = 'EL PROFESOR NO EXISTE'
				ELSE --SI LA MATERIA NO EXISTE
					SET @MSJ = 'LA MATERIA INGRESADA NO EXISTE'
			ELSE --SI LA MATERIA A ABRIR YA ESTÁ ABIERTA
				SET @MSJ = 'LA MATERIA ABIERTA YA EXISTE'
		COMMIT TRANSACTION
	END TRY
	 
	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--EJECUCION --------------------

SELECT * FROM MATERIAS_DISPONIBLES
SELECT * FROM MATERIAS
SELECT * FROM PROFESORES
SELECT * FROM GRUPOS
SELECT * FROM LABORATORIOS

GO
	DECLARE @RC int
	DECLARE @ID_MATERIA_ABIERTA varchar(10)
	DECLARE @ID_MATERIA varchar(10)
	DECLARE @ID_PROFESOR varchar(15)
	DECLARE @ID_GRUPO varchar(10)
	DECLARE @ID_LABORATORIO varchar(10)
	DECLARE @CUPO smallint
	DECLARE @DIA varchar(1)
	DECLARE @HORAINICIO time(7)
	DECLARE @HORAFIN time(7)
	DECLARE @F_INICIO date
	DECLARE @MSJ varchar(300)

	-- TODO: Set parameter values here.
	SET @ID_MATERIA_ABIERTA = 'A_PAWE_NJ'
	SET @ID_MATERIA = 'PAWE_NJ'
	SET @ID_PROFESOR = 'PRO-PVL93'
	SET @ID_GRUPO = 'G1_PAWE_NJ'
	SET @ID_LABORATORIO = 'LAB01-01'
	SET @CUPO = 16
	SET @DIA = 'L'
	SET @HORAINICIO = '14:00'
	SET @HORAFIN = '16:00'
	SET @F_INICIO = GETDATE()

	EXECUTE @RC = [dbo].[SP_ABRIR_MODULO] 
	   @ID_MATERIA_ABIERTA
	  ,@ID_MATERIA
	  ,@ID_PROFESOR
	  ,@ID_GRUPO
	  ,@ID_LABORATORIO
	  ,@CUPO
	  ,@DIA
	  ,@HORAINICIO
	  ,@HORAFIN
	  ,@F_INICIO
	  ,@MSJ OUTPUT
	  PRINT @MSJ
GO

------------------------------------------------------------------------------------------------
--2. PROCEDIMIENTO QUE PERMITE AGREGAR UN NUEVO HORARIO A UN GRUPO
GO
CREATE OR ALTER PROCEDURE SP_AGREGAR_HORARIO_MAT_DISP(@ID_GRUPO varchar(10), 												 
													 @DIA varchar(1),
													 @HORAINICIO time,
													 @HORAFIN time,
													 @F_INICIO date,
													 @MSJ varchar(300) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION --INICIA TRANSACCION
			IF (EXISTS(SELECT 1 FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO)) --SI EL GRUPO EXISTE
				IF(@DIA = 'L' OR @DIA = 'K' OR @DIA = 'M' OR @DIA = 'J' OR @DIA = 'V') --SI EL DIA ES L, K, M, J, O V
					IF (@HORAINICIO >= '7:00' AND @HORAFIN <= '18:00') --SI LA HORA SE ENCUENTRA DE 7 AM A 6 PM
						IF(SELECT dbo.F_CALCULA_CANT_HORAS_CLASE(@HORAINICIO, @HORAFIN)) = 1 --LLAMA FUNCION VERIFICA SI LA CANTIDAD DE HORAS ESTA ENTRE 2 Y 5 DIARIAS
							BEGIN
								INSERT INTO HORARIOS(ID_GRUPO, DIA, HORAINICIO, HORAFIN, F_INICIO) --INSERTA EN HORARIOS
									VALUES(@ID_GRUPO, @DIA, @HORAINICIO, @HORAFIN, @F_INICIO)							
								SET @MSJ = 'EL HORARIO SE AGREGO SATISFACTORIAMENTE'
							END
						ELSE --SI LA CANTIDAD DE HORAS ES MENOR A 2 O MAYOR A 5 DIARIAS
							SET @MSJ = 'POR REGLAMENTO DE LA UNIVERSIDAD UNA MATERIA DEBE TENER DE 2 A 5 HORAS DE CLASE DIARIAS'					
					ELSE --SI EL HORARIO ES ANTES DE LAS 7:00 O DESPUES DE LAS 6:00
						SET @MSJ = 'EL HORARIO DE CLASE DEBE ESTAR EN UN RANGO DE 7:00 A 18:00'
				ELSE --SI EL DIA NO ES DE LUNES A VIERNES
					SET @MSJ = 'EL DIA DEBE SER DE LUNES A VIERNES'
			ELSE --SI EL GRUPO A INSERTAR EL HORARIO NO EXISTE
				SET @MSJ = 'EL GRUPO INSERTADO NO EXISTE'
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--EJECUCION---------------------
SELECT * FROM HORARIOS
	ORDER BY ID_GRUPO
SELECT * FROM MATERIAS

GO
	DECLARE @RC int
	DECLARE @ID_GRUPO varchar(10)
	DECLARE @DIA varchar(1)
	DECLARE @HORAINICIO time(7)
	DECLARE @HORAFIN time(7)
	DECLARE @F_INICIO date
	DECLARE @MSJ varchar(300)

	-- TODO: Set parameter values here.
	SET @ID_GRUPO = 'G1_SIESIJ'
	SET @DIA = 'L'
	SET @HORAINICIO = '7:00'
	SET @HORAFIN = '13:00'
	SET @F_INICIO = '20230308'

	EXECUTE @RC = [dbo].[SP_AGREGAR_HORARIO_MAT_DISP] 
	   @ID_GRUPO
	  ,@DIA
	  ,@HORAINICIO
	  ,@HORAFIN
	  ,@F_INICIO
	  ,@MSJ OUTPUT
	  PRINT @MSJ
GO

----------------------------------------------------------------------------------------
--3. PROCEDIMIENTO ALMACENADO QUE PERMITE A LOS ESTUDIANTES MATRICULAR UNA MATERIA
GO
CREATE OR ALTER PROCEDURE SP_MATRICULAR_ESTUDIANTE(@ID_ESTUDIANTE varchar(10),
												 @ID_COMPROBANTE varchar(10),
												 @ID_MATERIA_ABIERTA varchar(10),
												 @NOTAPONDERADA decimal(10,2),
												 @DESCUENTO decimal(10,2),
												 @DETALLES varchar(200),
												 @ESTADO varchar(3),

												 @ID_GRUPO varchar(10),
												 @F_INICIO date,

												 @MSJ varchar(200) OUT)
AS
	BEGIN TRY
		BEGIN TRANSACTION
			IF(EXISTS(SELECT 1 FROM MATERIAS_DISPONIBLES WHERE ID_MATERIA_ABIERTA = @ID_MATERIA_ABIERTA)) --SI LA MATERIA EXISTE
				IF (SELECT dbo.F_VERIFICAR_REQUISITOS_MATERIA(@ID_ESTUDIANTE, @ID_MATERIA_ABIERTA)) = 1 --SI APROBÓ LOS CURSOS POSTERIORES
					IF (SELECT dbo.F_VERIFICAR_ESTUDIANTE_MOROSO(@ID_ESTUDIANTE)) = 0 --SI EL ESTUDIANTE NO ESTÁ MOROSO
						IF (EXISTS(SELECT 1 FROM GRUPOS WHERE ID_GRUPO = @ID_GRUPO)) -- SI EL GRUPO NO EXISTE
							BEGIN			
								--DECLARAN VARIABLES
								DECLARE @DIA varchar(1), 
										@HORAINICIO time,
										@HORAFIN time,
										@F_FIN date

								SET @DIA = (SELECT DIA FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO)--ALMACENA EL DIA DEL HORARIO DEL GRUPO QUE SLECCIONO
								SET @HORAINICIO = (SELECT HORAINICIO FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO) --ALMACENA LA HORA DE INICIO DEL HORARIO DEL GRUPO
								SET @HORAFIN = (SELECT HORAFIN FROM HORARIOS WHERE ID_GRUPO = @ID_GRUPO) --ALMACENA LA HORA DE FIN DEL HORARIO DEL GRUPO
								
								IF (SELECT dbo.F_CHOQUE_HORARIOS_ESTUDIANTES(@ID_ESTUDIANTE, @DIA, @HORAINICIO, @HORAFIN)) = 0 --SI NO EXISTE UN CHOQUE DE HORARIOS
									BEGIN
										INSERT INTO MATRICULAS(ID_COMPROBANTE, ID_ESTUDIANTE ,ID_MATERIA_ABIERTA, NOTAPONDERADA, DESCUENTO, DETALLES, ESTADO) --INSERTA EN MATRICULAS
											VALUES(@ID_COMPROBANTE, @ID_ESTUDIANTE, @ID_MATERIA_ABIERTA, @NOTAPONDERADA, @DESCUENTO, @DETALLES, @ESTADO)									
										SET @F_FIN = (SELECT dbo.F_CALCULA_FECHA_FIN(@ID_GRUPO, @ID_MATERIA_ABIERTA, @F_INICIO)) --LLAMA FUNCION CALCULA FECHA FINALIZACION
										SET @MSJ = 'MATRICULA REALIZADA SATISFACTORIAMENTE'
									END
								ELSE --SI EXISTE UN CHOQUE DE HORARIOS
									SET @MSJ = 'EXISTE UN CHOQUE DE HORARIOS'
							END
						ELSE --SI EL GRUPO NO EXISTE
							SET @MSJ = 'EL GRUPO INGRESADO NO EXISTE'
					ELSE --SI EL ESTUDIANTE ESTA MOROSO
						SET @MSJ = 'EL ESTUDIANTE SE ENCUNETRA MOROSO'
				ELSE --SI NO HA APROBADO LOS CURSOS PASADOS
					SET @MSJ = 'EL ESTUDIANTE NO HA APROBADO LOS CURSOS ANTERIORES AL CURSO ACTUAL'
			ELSE --SI LA MATERIA NO EXISTE
				SET @MSJ = 'LA MATERIA ABIERTA NO EXISTE'
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH  --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--EJECUCION --------------------
GO
	DECLARE @RC int
	DECLARE @ID_ESTUDIANTE varchar(10)
	DECLARE @ID_COMPROBANTE varchar(10)
	DECLARE @ID_MATERIA_ABIERTA varchar(10)
	DECLARE @NOTAPONDERADA decimal(10,2)
	DECLARE @DESCUENTO decimal(10,2)
	DECLARE @DETALLES varchar(200)
	DECLARE @ESTADO varchar(3)
	DECLARE @ID_GRUPO varchar(10)
	DECLARE @F_INICIO date
	DECLARE @MSJ varchar(200)

	-- TODO: Set parameter values here.
	SET @ID_ESTUDIANTE = 'AML0980'
	SET @ID_COMPROBANTE = 'C12'
	SET @ID_MATERIA_ABIERTA = 'A_DIMO_A1'
	SET @NOTAPONDERADA = 90
	SET @DESCUENTO = 0.02
	SET @DETALLES = 'SIN DETALLES'
	SET @ESTADO = 'ACT'
	SET @ID_GRUPO = 'G1_DIMOA2'
	SET @F_INICIO = GETDATE()

	EXECUTE @RC = [dbo].[SP_MATRICULAR_ESTUDIANTE] 
	   @ID_ESTUDIANTE
	  ,@ID_COMPROBANTE
	  ,@ID_MATERIA_ABIERTA
	  ,@NOTAPONDERADA
	  ,@DESCUENTO
	  ,@DETALLES
	  ,@ESTADO
	  ,@ID_GRUPO
	  ,@F_INICIO
	  ,@MSJ OUTPUT
	  PRINT @MSJ
GO

SELECT * FROM MATRICULAS
SELECT * FROM MATERIAS_DISPONIBLES
SELECT * FROM ESTUDIANTES
SELECT * FROM GRUPOS

----------------------------------------------------------------------------------------
--4. PROCEDIMIENTO ALMACENADO PARA CREAR NUEVA MATERIA Y ASIGNARLE UNA CARRERA
GO
CREATE OR ALTER PROCEDURE SP_ASIGNAR_MATERIA_A_CARRERA(@ID_MATERIA varchar(10),
														@ID_CARRERA varchar(10),
														@ID_PROFESOR_CERTIFICADO varchar(10),
														@NOMBRE varchar(150),
														@HORAS int,
														@COSTO decimal(10,2),
														@CREDITOS smallint,
														@REQUISITOS varchar(10),
														@DETALLES varchar(200),
														@ESTADO varchar(3),
														@BORRADO_M bit,
														@MSJ varchar(200) OUT)
AS
	BEGIN TRY --CONTROL DE ERRORES
		BEGIN TRANSACTION --INICIA TRANSACCION
			IF(NOT EXISTS(SELECT 1 FROM MATERIAS WHERE ID_MATERIA = @ID_MATERIA)) --SI LA MATERIA NO EXISTE
				IF(EXISTS(SELECT 1 FROM CARRERAS WHERE ID_CARRERA = @ID_CARRERA)) --SI LA CARRERA EXISTE
					IF(EXISTS(SELECT 1 FROM PROFESORES_CERTIFICADOS WHERE ID_PROFESOR_CERTIFICADO = @ID_PROFESOR_CERTIFICADO)) --SI EL PROFESOR CERTIFICADO EXISTE
						BEGIN
							INSERT INTO MATERIAS(ID_MATERIA, ID_CARRERA, ID_PROFESOR_CERTIFICADO, NOMBRE, HORAS, COSTO, CREDITOS, REQUISITOS, DETALLES, ESTADO, BORRADO_M) --INSERTA LA INFORMACION DE LA MATERIA, ASIGNANDOLE LA CARRERA
								VALUES(@ID_MATERIA, @ID_CARRERA, @ID_PROFESOR_CERTIFICADO, @NOMBRE, @HORAS, @COSTO, @CREDITOS, @REQUISITOS, @DETALLES, @ESTADO, @BORRADO_M)
							SET @MSJ = 'LA MATERIA HA SIDO CREADA Y ASIGNADA A UNA CARRERA'
						END
					ELSE --SI EL PROFESOR NO EXISTE
						SET @MSJ = 'EL PROFESOR CERTIFICADO NO EXISTE'
				ELSE --SI LA CARRERA A LA CUAL LE ASIGNA LA MATERIA NO EXISTE
					SET @MSJ = 'LA CARRERA NO EXISTE'
			ELSE --SI LA MATERIA YA EXISTE
				SET @MSJ = 'LA MATERIA YA EXISTE'
		COMMIT TRANSACTION
	END TRY

	BEGIN CATCH --SI HAY ERRORES AQUI LOS ATRAPA Y EL ROLLBACK DEVUELVE LA EJECUCION
		ROLLBACK TRANSACTION
		SET @MSJ = ERROR_MESSAGE()
	END CATCH
GO

--EJECUCION --------------------
GO
	DECLARE @RC int
	DECLARE @ID_MATERIA varchar(10)
	DECLARE @ID_CARRERA varchar(10)
	DECLARE @ID_PROFESOR_CERTIFICADO varchar(10)
	DECLARE @NOMBRE varchar(150)
	DECLARE @HORAS int
	DECLARE @COSTO decimal(10,2)
	DECLARE @CREDITOS smallint
	DECLARE @REQUISITOS varchar(10)
	DECLARE @DETALLES varchar(200)
	DECLARE @ESTADO varchar(3)
	DECLARE @BORRADO_M bit
	DECLARE @MSJ varchar(200)

	-- TODO: Set parameter values here.
	SET @ID_MATERIA = 'MATPRU_1'
	SET @ID_CARRERA = 'TEC_PRVI'
	SET @ID_PROFESOR_CERTIFICADO = 'PC9'
	SET @NOMBRE = 'NUEVA MATERIA'
	SET @HORAS = 205
	SET @COSTO = 250000
	SET @CREDITOS = 9
	SET @REQUISITOS = 'NO APLICA'
	SET @DETALLES = 'SIN DETALLES'
	SET @ESTADO = 'ABI'
	SET @BORRADO_M = 0

	EXECUTE @RC = [dbo].[SP_ASIGNAR_MATERIA_A_CARRERA] 
	   @ID_MATERIA
	  ,@ID_CARRERA
	  ,@ID_PROFESOR_CERTIFICADO
	  ,@NOMBRE
	  ,@HORAS
	  ,@COSTO
	  ,@CREDITOS
	  ,@REQUISITOS
	  ,@DETALLES
	  ,@ESTADO
	  ,@BORRADO_M
	  ,@MSJ OUTPUT
	  PRINT @MSJ
GO

SELECT * FROM MATERIAS
SELECT * FROM CARRERAS
SELECT * FROM PROFESORES_CERTIFICADOS

--****************************************************************************************************************************************************************************
--TRIGGERS *******************************************************************************************************************************************************************

--1. TRIGGER QUE RESTA UN ESPACIO DEL CUPO CUANDO SE MATRICULA UN ESTUDIANTE
GO
CREATE OR ALTER TRIGGER TR_RESTAR_CUPO_MATRICULA
ON MATRICULAS
FOR INSERT
AS
	--DECLARAN LAS VARIABLES
	DECLARE @ID_ESTUDIANTE varchar(10), 
			@ID_COMPROBANTE varchar(10),
			@ID_MATERIA_ABIERTA varchar(10),
			@NOTAPONDERADA decimal(10,2),
			@DESCUENTO decimal(10,2),
			@DETALLES varchar(200),
			@ID_GRUPO varchar(10)

	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA INSERTED
	SELECT @ID_ESTUDIANTE = ID_ESTUDIANTE from inserted 
	SELECT @ID_COMPROBANTE = ID_COMPROBANTE from inserted
	SELECT @ID_MATERIA_ABIERTA = ID_MATERIA_ABIERTA from inserted
	SELECT @NOTAPONDERADA = NOTAPONDERADA from inserted
	SELECT @DESCUENTO = DESCUENTO from inserted
	SELECT @DETALLES = DETALLES from inserted
	SELECT @ID_GRUPO = ID_GRUPO from GRUPOS
	
	--RESTA UN ESPACIO DEL CUPO SI EL ID DEL GRUPO ES IGUAL
	UPDATE GRUPOS SET CUPO = CUPO - 1
		WHERE ID_GRUPO = @ID_GRUPO
GO

SELECT * FROM GRUPOS

----------------------------------------------------------------------------------------
--2. TRIGGER QUE ACTUALIZA EL DESCUENTO SI LA NOTA PONDERADA DEL ESTUDIANTE ES MAYOR O IGUAL A 95
GO
CREATE TRIGGER TR_DESCUENTO_POR_EXCELECIA
ON MATRICULAS
FOR INSERT
AS
	--DECLARAN LAS VARIABLES
	DECLARE @ID_COMPROBANTE varchar(10),
			@ID_ESTUDIANTE varchar(10),
			@ID_MATERIA_ABIERTA varchar(10),
			@NOTA_PONDERADA decimal(10,2),
			@DESCUENTO decimal(10,2),
			@DETALLES varchar(200)

	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA INSERTED
	SELECT @ID_COMPROBANTE = ID_COMPROBANTE from inserted
	SELECT @ID_ESTUDIANTE = ID_ESTUDIANTE from inserted
	SELECT @ID_MATERIA_ABIERTA = ID_MATERIA_ABIERTA from inserted
	SELECT @NOTA_PONDERADA = NOTAPONDERADA from inserted
	SELECT @DESCUENTO = DESCUENTO from inserted
	SELECT @DETALLES = DETALLES from inserted

	--SELECCIONA LA NOTA DEL ESTUDIANTE RESPECTIVO, SI ES MAYOR O IGUAL A 95 ACTUALIZA EL DESC A 0.05
	IF(SELECT NOTAPONDERADA FROM MATRICULAS WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE) >= 95
		UPDATE MATRICULAS SET
			DESCUENTO = 0.05,
			DETALLES = 'DESCUENTO POR EXCELENCIA'
		WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE
GO

SELECT * FROM LABORATORIOS
SELECT * FROM GRUPOS

----------------------------------------------------------------------------------------
--3. TRIGGER QUE BORRA LOGICAMENTE UN ESTUDIANTE Y SU MATRICULA SI SU ESTADO ES INACTIVO
GO
CREATE OR ALTER TRIGGER TR_ESTUDIANTE_INACTIVO
ON ESTUDIANTES
FOR UPDATE
AS
	--DECLARAN VARIABLES
	DECLARE @ID_ESTUDIANTE varchar(10)

	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA INSERTED
	SELECT @ID_ESTUDIANTE = ID_ESTUDIANTE FROM inserted

	--ACTUALIZA MATRICULAS SI EL ESTADO DEL RESPECTIVO ESTUDIANTE ES INA
	UPDATE MATRICULAS 
	SET ESTADO = 'INA'
	FROM MATRICULAS
	WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE AND (SELECT BORRADO_E FROM ESTUDIANTES WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE) = 1 --SI EL BORRADO DEL ESTUDIANTE ES 1
GO

--PRUEBA -----------------------
UPDATE ESTUDIANTES 
	SET BORRADO_E = 1
	WHERE ID_ESTUDIANTE = 'JPM0765'

SELECT * FROM ESTUDIANTES
SELECT * FROM MATRICULAS

----------------------------------------------------------------------------------------
--4. TRIGGER QUE BORRA LOGICAMENTE UN EMPLEADO, Y ACTUALIZA EL ESTADO EN PROFESORES A 'INA' 
--Y EL BOORADO SI EL ESTADO EN EMPLEADOS ES INACTIVO 

GO
CREATE OR ALTER TRIGGER TR_EMPLEADO_INACTIVO
ON EMPLEADOS
FOR UPDATE
AS
	--DECLARAN VARIABLES
	DECLARE @ID_EMPLEADO varchar(10)

	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA INSERTED
	SELECT @ID_EMPLEADO = ID_EMPLEADO FROM inserted

	--ACTUALIZA EN PROFESORES EL ESTADO A INA Y EL BORRADO A 1 SI CORRESPONDE SEGUN EL ID Y SI EL EMPLADO ESTA INCATIVO
	UPDATE PROFESORES 
	SET ESTADO = 'INA',
		BORRADO_P = 1
	FROM PROFESORES
	WHERE ID_EMPLEADO = @ID_EMPLEADO AND (SELECT ESTADO FROM EMPLEADOS WHERE ID_EMPLEADO = @ID_EMPLEADO) = 'INA'
GO

--PRUEBA -----------------------
UPDATE EMPLEADOS 
	SET ESTADO = 'INA'
	WHERE ID_EMPLEADO = 'E0-ABP555'

SELECT * FROM EMPLEADOS
SELECT * FROM PROFESORES

----------------------------------------------------------------------------------------
--5. TRIGGER QUE ACTUALIZA EN FERIADOS SI APLICA O NO EL FERIADO (SI ES O NO FIN DE SEMANA)
--A LAS LEECIONES

GO
CREATE TRIGGER TR_FERIADO_FIN_SEMANA
ON FERIADOS
FOR INSERT

AS
	--DECLARAN VARIABLES
	DECLARE @FECHA DATE
	DECLARE @ES_FIN_SEMANA INT
	
	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA INSERTED
	SELECT @FECHA = FECHA from inserted

	--VERIFICA SI EL DIA DEL FERIADO NO ES 1: DOMINGO O 7: SABADO
	IF DATEPART(WEEKDAY, @FECHA) NOT IN (1, 7)
		SET @ES_FIN_SEMANA = 0 
	ELSE --SI CORRESPONDE A UN FIN DE SEMANA
		SET @ES_FIN_SEMANA = 1

	--ACTUALIZA EN FERIADOS SI APLICA SEGUN LA FECHA CONSULTADA
	UPDATE FERIADOS 
		SET APLICA = @ES_FIN_SEMANA
		FROM FERIADOS
		WHERE FECHA = @FECHA
GO

--PRUEBA -----------------------
INSERT INTO FERIADOS(FECHA, ID_GRUPO)
	VALUES('20231201', 'G1_DIMOA1')

	
------------------------------------------------------------------------------------
--6. TRIGGER QUE BORRA LA FACTURA CUANDO SE BORRA UNA MATRICULA
GO
CREATE OR ALTER TRIGGER TR_BORRAR_MATRICULA
ON MATRICULAS
FOR DELETE
AS
	--DECLARAN VARIABLES
	DECLARE @ID_COMPROBANTE varchar(10)

	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA DELETED
	SELECT @ID_COMPROBANTE = ID_COMPROBANTE FROM deleted

	--BORRA EN FACTURAS EL QUE CORRESPONDA AL COMPROBANTE
	DELETE FROM FACTURAS
		WHERE ID_COMPROBANTE = @ID_COMPROBANTE
GO

--PRUEBA -----------------------
--BORRAR LAS RESTRICCIONES
ALTER TABLE FACTURAS DROP CONSTRAINT FK_ID_COMPROBANTE_F
ALTER TABLE REGISTRO_NOTAS DROP CONSTRAINT FK_ID_COMPROBANTE_RN

--BORRAR EL DATO
DELETE FROM MATRICULAS WHERE ID_COMPROBANTE = 'C6'

SELECT * FROM MATRICULAS
SELECT * FROM FACTURAS

----------------------------------------------------------------------------------------
--7. TRIGGER QUE ACTUALIZA A ACTIVO EL ESTADO DEL ESTUDIANTE CUANDO HACE UNA MATRICULA
GO
CREATE OR ALTER TRIGGER TR_ACTIVAR_ESTUDIANTE
ON MATRICULAS
FOR INSERT
AS
	--DECLARAN VARIABLES
	DECLARE @ID_ESTUDIANTE varchar(10)

	--SE TRABAJA CON LAS VALORES QUE INGRESAN EN LA TABLA INSERTED
	SELECT @ID_ESTUDIANTE = ID_ESTUDIANTE from inserted

	--ACTUALIZA EN ESTUDIANTES EL ESTADO DEL ESTUDIANTE A ACTIVO
	UPDATE ESTUDIANTES
	SET ESTADO = 'ACT'
	WHERE ID_ESTUDIANTE = @ID_ESTUDIANTE
GO

--PRUEBA -----------------------
INSERT INTO MATRICULAS(ID_COMPROBANTE, ID_ESTUDIANTE, ID_MATERIA_ABIERTA, NOTAPONDERADA, DESCUENTO, DETALLES)
	VALUES('C12', 'APM0754', 'A_DIMO_A1', '88.8', 0, 'SIN DETALLES')

SELECT * FROM ESTUDIANTES
SELECT * FROM MATRICULAS
SELECT * FROM MATERIAS_DISPONIBLES